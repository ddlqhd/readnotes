---
layout: post
title:  "[Effective C#] 第2条：考虑用readonly代替const"
date:   2023-04-23 21:17:00 +0800
categories: c#
tag: Effective C#
---

C#有两种常量，一种是编译期（const）的常量，另一种是运行期（readonly）的常量，编译期的常量虽然能令程序运行得稍快一点，但却远不如运行期的常量那样灵活。只有当程序**性能极端重要且常量取值不会随版本而变化**的情况下，才可以考虑选用这种常量。

{% highlight csharp %}
//Compile—time Constant：
public const int Millennium = 2000;

//Runtime Constant：
public static readonly int ThisYear = 2023;
{% endhighlight %}
上面这段代码演示了怎样在class（类）或struct（结构体）的范围之内声明这两种常量。此外，**编译期的常量还可以在方法里面声明，而readonly常量则不行**。

在访问这两种常量时，他们的行为也不同，const常量类似于C里面的宏定义，在编译成MSIL之后，代码中的常量名直接被替换为了常量的值，类似于宏定义的替换，而readonly常量仍保持了其变量名引用。

这两种常量所支持的值也不一样。编译期常量只能用数字、字符串或null来初始化。readonly常量在执行完构造函数（constructor）之后，就不能再修改了，但和编译器常量不同，它的值是在程序运行的时候才得以初始化的，它的类型不受限制。

两者的另一个区别在于：readonly可以用来声明实例级别的常量，以便给同一个类的每个实例设定不同的常量值，而const常量则是静态常量。

readonly常量是在程序运行的时候才加以解析的，也就是说，如果代码里面用到了这样的常量，那么由这段代码所生成的IL码会通过引用的方式来使用这个readonly量，而不会直接使用常量值本身。这对代码的维护工作有很大影响，因为在生成IL的时候，代码中的编译期常量会直接以字面值的形式写进去，如果你在制作另外一个程序集（assembly）的时候用到了本程序集里面的这个常量，那么它会直接以字面值的形式写到那个程序集里面。也就是说在程序更新补丁的时候，如果编译期常量则两个程序集必须一起更新，单独更新编译期常量所在的程序集，另一个程序集无法生效，而由于readonly常量在程序集中保留了对变量的引用，所以他则没有这个问题。

const关键字用来声明那些必须在编译期得以确定的值，例如attribute的参数、switch case语句的标签、enum的定义等，偶尔还用来声明那些不会随着版本而变化的值。除此之外的值则应该考虑声明成更加灵活的readonly常量。